`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/19/2025 06:24:39 PM
// Design Name: 
// Module Name: im
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////

module im(
    input wire [31:0] address,     
    output reg [31:0] instruction  
);
    parameter MEM_SIZE = 256;

    reg [31:0] mem [0:MEM_SIZE-1];

always @(*) begin
        if (address >= 0 && address < MEM_SIZE) begin
            instruction = mem[address];
        end else begin
            instruction = 32'h00000000; 
        end
    end

integer i;
    initial begin
        for (i = 0; i < MEM_SIZE; i = i + 1) begin
            mem[i] = 32'h00000000;
        end
        // Format: y(10)|rd(6)|rs(6)|rt(6)|opcode(4)
        
        mem[0] = 32'b0000000000_001111_001111_001111_0111; // SUB x15,x15,x15 (create 0)
        mem[1] = 32'b0000000001_001110_001111_000000_0101; // INC x14,x15,1 (create 1)
        mem[2] = 32'b0000000000_000101_001100_001110_0111; // SUB x5,x12,x14 (N-1) [x3->x12]
        mem[3] = 32'b0000000000_001000_001010_000000_1110; // LD x8,x10,0 (a[0]) [x1->x10]
        mem[4] = 32'b0000000000_000000_000000_000000_0000; // NOP (load delay)
        mem[5] = 32'b0000000000_000000_000000_000000_0000; // NOP
        mem[6] = 32'b0000000000_000000_001011_001000_0011; // ST x8,x11,0 (b[0]) [x2->x11]
        mem[7] = 32'b0000000000_000110_001010_000101_0100; // ADD x6,x10,x5 (a[N-1] addr) [x1->x10]
        mem[8] = 32'b0000000000_000111_001011_000101_0100; // ADD x7,x11,x5 (b[N-1] addr) [x2->x11]
        mem[9] = 32'b0000000000_001000_000110_000000_1110; // LD x8,x6,0 (a[N-1])
        mem[10] = 32'b0000000000_000000_000000_000000_0000; // NOP (load delay)
        mem[11] = 32'b0000000000_000000_000000_000000_0000; // NOP
        mem[12] = 32'b0000000000_000000_000111_001000_0011; // ST x8,x7,0 (b[N-1])
        mem[13] = 32'b0000000001_000100_001111_000000_0101; // INC x4,x15,1 (i=1)
        mem[14] = 32'b0000110100_010101_000000_000000_1111; // SVPC x21,52 (LOOP_END: 66-14=52)
        mem[15] = 32'b0000000111_010110_000000_000000_1111; // SVPC x22,7 (LOAD_VALS: 22-15=7)
        mem[16] = 32'b0000000001_010100_000000_000000_1111; // SVPC x20,1 (LOOP_START: 17-16=1)
        
        // Main loop
        mem[17] = 32'b0000000000_001101_000100_000101_0111; // LOOP_START: SUB x13,x4,x5 (check i<N-1)
        mem[18] = 32'b0000000000_000000_000000_000000_0000; // NOP (flag delay 1)
        mem[19] = 32'b0000000000_000000_000000_000000_0000; // NOP (flag delay 2)
        mem[20] = 32'b0000000000_000000_010110_000000_1010; // BRN x22 (to LOAD_VALS)
        mem[21] = 32'b0000000000_000000_010101_000000_1000; // J x21 (to LOOP_END)
        
        // Load 3-element window
        mem[22] = 32'b0000000000_000000_000000_000000_0000; // LOAD_VALS: NOP (iteration bubble)
        mem[23] = 32'b0000000000_010001_000100_001110_0111; // SUB x17,x4,x14 (i-1) [x11->x17]
        mem[24] = 32'b0000000000_010001_001010_010001_0100; // ADD x17,x10,x17 [x11->x17, x1->x10]
        mem[25] = 32'b0000000000_001000_010001_000000_1110; // LD x8,x17,0 (a[i-1]) [x11->x17]
        mem[26] = 32'b0000000000_000110_001010_000100_0100; // ADD x6,x10,x4 [x1->x10]
        mem[27] = 32'b0000000000_001001_000110_000000_1110; // LD x9,x6,0 (a[i])
        mem[28] = 32'b0000000000_010010_000100_001110_0100; // ADD x18,x4,x14 (i+1) [x12->x18]
        mem[29] = 32'b0000000000_010010_001010_010010_0100; // ADD x18,x10,x18 [x12->x18, x1->x10]
        mem[30] = 32'b0000000000_010000_010010_000000_1110; // LD x16,x18,0 (a[i+1]) [x10->x16, x12->x18]
        
        // SWAP1: compare x8 and x9
        mem[31] = 32'b0000000000_001101_001000_001001_0111; // SUB x13,x8,x9
        mem[32] = 32'b0000000000_000000_000000_000000_0000; // NOP (flag delay)
        mem[33] = 32'b0000001000_010111_000000_000000_1111; // SVPC x23,8 (NO_SWAP_1: 41-33=8)
        mem[34] = 32'b0000000000_000000_000000_000000_0000; // NOP (SVPC WB delay 1)
        mem[35] = 32'b0000000000_000000_000000_000000_0000; // NOP (SVPC WB delay 2)
        mem[36] = 32'b0000000000_000000_010111_000000_1010; // BRN x23 (if x8<x9, no swap)
        mem[37] = 32'b0000000000_000000_010111_000000_1001; // BRZ x23 (if x8==x9, no swap)
        mem[38] = 32'b0000000000_001101_001000_001111_0100; // ADD x13,x8,x15 (swap: temp=x8)
        mem[39] = 32'b0000000000_001000_001001_001111_0100; // ADD x8,x9,x15 (x8=x9)
        mem[40] = 32'b0000000000_001001_001101_001111_0100; // ADD x9,x13,x15 (x9=temp)
        
        // SWAP2: compare x9 and x16
        mem[41] = 32'b0000000000_001101_001001_010000_0111; // NO_SWAP_1: SUB x13,x9,x16 [x10->x16]
        mem[42] = 32'b0000000000_000000_000000_000000_0000; // NOP (flag delay)
        mem[43] = 32'b0000001000_011000_000000_000000_1111; // SVPC x24,8 (NO_SWAP_2: 51-43=8)
        mem[44] = 32'b0000000000_000000_000000_000000_0000; // NOP (SVPC WB delay 1)
        mem[45] = 32'b0000000000_000000_000000_000000_0000; // NOP (SVPC WB delay 2)
        mem[46] = 32'b0000000000_000000_011000_000000_1010; // BRN x24 (if x9<x16, no swap)
        mem[47] = 32'b0000000000_000000_011000_000000_1001; // BRZ x24 (if x9==x16, no swap)
        mem[48] = 32'b0000000000_001101_001001_001111_0100; // ADD x13,x9,x15 (swap: temp=x9)
        mem[49] = 32'b0000000000_001001_010000_001111_0100; // ADD x9,x16,x15 (x9=x16) [x10->x16]
        mem[50] = 32'b0000000000_010000_001101_001111_0100; // ADD x16,x13,x15 (x16=temp) [x10->x16]
        
        // SWAP3: compare x8 and x9 again
        mem[51] = 32'b0000000000_001101_001000_001001_0111; // NO_SWAP_2: SUB x13,x8,x9
        mem[52] = 32'b0000000000_000000_000000_000000_0000; // NOP (flag delay)
        mem[53] = 32'b0000001000_011001_000000_000000_1111; // SVPC x25,8 (NO_SWAP_3: 61-53=8)
        mem[54] = 32'b0000000000_000000_000000_000000_0000; // NOP (SVPC WB delay 1)
        mem[55] = 32'b0000000000_000000_000000_000000_0000; // NOP (SVPC WB delay 2)
        mem[56] = 32'b0000000000_000000_011001_000000_1010; // BRN x25 (if x8<x9, no swap)
        mem[57] = 32'b0000000000_000000_011001_000000_1001; // BRZ x25 (if x8==x9, no swap)
        mem[58] = 32'b0000000000_001101_001000_001111_0100; // ADD x13,x8,x15 (swap: temp=x8)
        mem[59] = 32'b0000000000_001000_001001_001111_0100; // ADD x8,x9,x15 (x8=x9)
        mem[60] = 32'b0000000000_001001_001101_001111_0100; // ADD x9,x13,x15 (x9=temp)
        
        // Store median and loop back
        mem[61] = 32'b0000000000_000000_000000_000000_0000; // NO_SWAP_3: NOP (delay)
        mem[62] = 32'b0000000000_000111_001011_000100_0100; // ADD x7,x11,x4 (b[i] addr) [x2->x11]
        mem[63] = 32'b0000000000_000000_000111_001001_0011; // ST x9,x7,0 (store median)
        mem[64] = 32'b0000000001_000100_000100_000000_0101; // INC x4,x4,1 (i++)
        mem[65] = 32'b0000000000_000000_010100_000000_1000; // J x20 (to LOOP_START)
        
        mem[66] = 32'b0000000000_011110_001010_000000_0110; // LOOP_END: NEG x30, x10 (x30 = -x10 = -2)
        mem[67] = 32'b0000000000_000000_000000_000000_0000; // NOP
    end
endmodule
